"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkInterface = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Provides an Elastic network interface (ENI) resource.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const test = new aws.ec2.NetworkInterface("test", {
 *     subnetId: aws_subnet.public_a.id,
 *     privateIps: ["10.0.0.50"],
 *     securityGroups: [aws_security_group.web.id],
 *     attachments: [{
 *         instance: aws_instance.test.id,
 *         deviceIndex: 1,
 *     }],
 * });
 * ```
 * ### Example of Managing Multiple IPs on a Network Interface
 *
 * By default, private IPs are managed through the `privateIps` and `privateIpsCount` arguments which manage IPs as a set of IPs that are configured without regard to order. For a new network interface, the same primary IP address is consistently selected from a given set of addresses, regardless of the order provided. However, modifications of the set of addresses of an existing interface will not alter the current primary IP address unless it has been removed from the set.
 *
 * In order to manage the private IPs as a sequentially ordered list, configure `privateIpListEnabled` to `true` and use `privateIpList` to manage the IPs. This will disable the `privateIps` and `privateIpsCount` settings, which must be removed from the config file but are still exported. Note that changing the first address of `privateIpList`, which is the primary, always requires a new interface.
 *
 * If you are managing a specific set or list of IPs, instead of just using `privateIpsCount`, this is a potential workflow for also leveraging `privateIpsCount` to have AWS automatically assign additional IP addresses:
 *
 * 1. Comment out `privateIps`, `privateIpList`, `privateIpListEnabled` in your configuration
 * 2. Set the desired `privateIpsCount` (count of the number of secondaries, the primary is not included)
 * 3. Apply to assign the extra IPs
 * 4. Remove `privateIpsCount` and restore your settings from the first step
 * 5. Add the new IPs to your current settings
 * 6. Apply again to update the stored state
 *
 * This process can also be used to remove IP addresses in addition to the option of manually removing them. Adding IP addresses in a manually is more difficult because it requires knowledge of which addresses are available.
 *
 * ## Import
 *
 * Network Interfaces can be imported using the `id`, e.g.,
 *
 * ```sh
 *  $ pulumi import aws:ec2/networkInterface:NetworkInterface test eni-e5aa89a3
 * ```
 */
class NetworkInterface extends pulumi.CustomResource {
    constructor(name, argsOrState, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            resourceInputs["arn"] = state ? state.arn : undefined;
            resourceInputs["attachments"] = state ? state.attachments : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["interfaceType"] = state ? state.interfaceType : undefined;
            resourceInputs["ipv4PrefixCount"] = state ? state.ipv4PrefixCount : undefined;
            resourceInputs["ipv4Prefixes"] = state ? state.ipv4Prefixes : undefined;
            resourceInputs["ipv6AddressCount"] = state ? state.ipv6AddressCount : undefined;
            resourceInputs["ipv6AddressListEnabled"] = state ? state.ipv6AddressListEnabled : undefined;
            resourceInputs["ipv6AddressLists"] = state ? state.ipv6AddressLists : undefined;
            resourceInputs["ipv6Addresses"] = state ? state.ipv6Addresses : undefined;
            resourceInputs["ipv6PrefixCount"] = state ? state.ipv6PrefixCount : undefined;
            resourceInputs["ipv6Prefixes"] = state ? state.ipv6Prefixes : undefined;
            resourceInputs["macAddress"] = state ? state.macAddress : undefined;
            resourceInputs["outpostArn"] = state ? state.outpostArn : undefined;
            resourceInputs["ownerId"] = state ? state.ownerId : undefined;
            resourceInputs["privateDnsName"] = state ? state.privateDnsName : undefined;
            resourceInputs["privateIp"] = state ? state.privateIp : undefined;
            resourceInputs["privateIpListEnabled"] = state ? state.privateIpListEnabled : undefined;
            resourceInputs["privateIpLists"] = state ? state.privateIpLists : undefined;
            resourceInputs["privateIps"] = state ? state.privateIps : undefined;
            resourceInputs["privateIpsCount"] = state ? state.privateIpsCount : undefined;
            resourceInputs["securityGroups"] = state ? state.securityGroups : undefined;
            resourceInputs["sourceDestCheck"] = state ? state.sourceDestCheck : undefined;
            resourceInputs["subnetId"] = state ? state.subnetId : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["tagsAll"] = state ? state.tagsAll : undefined;
        }
        else {
            const args = argsOrState;
            if ((!args || args.subnetId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'subnetId'");
            }
            resourceInputs["attachments"] = args ? args.attachments : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["interfaceType"] = args ? args.interfaceType : undefined;
            resourceInputs["ipv4PrefixCount"] = args ? args.ipv4PrefixCount : undefined;
            resourceInputs["ipv4Prefixes"] = args ? args.ipv4Prefixes : undefined;
            resourceInputs["ipv6AddressCount"] = args ? args.ipv6AddressCount : undefined;
            resourceInputs["ipv6AddressListEnabled"] = args ? args.ipv6AddressListEnabled : undefined;
            resourceInputs["ipv6AddressLists"] = args ? args.ipv6AddressLists : undefined;
            resourceInputs["ipv6Addresses"] = args ? args.ipv6Addresses : undefined;
            resourceInputs["ipv6PrefixCount"] = args ? args.ipv6PrefixCount : undefined;
            resourceInputs["ipv6Prefixes"] = args ? args.ipv6Prefixes : undefined;
            resourceInputs["privateIp"] = args ? args.privateIp : undefined;
            resourceInputs["privateIpListEnabled"] = args ? args.privateIpListEnabled : undefined;
            resourceInputs["privateIpLists"] = args ? args.privateIpLists : undefined;
            resourceInputs["privateIps"] = args ? args.privateIps : undefined;
            resourceInputs["privateIpsCount"] = args ? args.privateIpsCount : undefined;
            resourceInputs["securityGroups"] = args ? args.securityGroups : undefined;
            resourceInputs["sourceDestCheck"] = args ? args.sourceDestCheck : undefined;
            resourceInputs["subnetId"] = args ? args.subnetId : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["macAddress"] = undefined /*out*/;
            resourceInputs["outpostArn"] = undefined /*out*/;
            resourceInputs["ownerId"] = undefined /*out*/;
            resourceInputs["privateDnsName"] = undefined /*out*/;
            resourceInputs["tagsAll"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(NetworkInterface.__pulumiType, name, resourceInputs, opts);
    }
    /**
     * Get an existing NetworkInterface resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new NetworkInterface(name, state, Object.assign(Object.assign({}, opts), { id: id }));
    }
    /**
     * Returns true if the given object is an instance of NetworkInterface.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === NetworkInterface.__pulumiType;
    }
}
exports.NetworkInterface = NetworkInterface;
/** @internal */
NetworkInterface.__pulumiType = 'aws:ec2/networkInterface:NetworkInterface';
//# sourceMappingURL=networkInterface.js.map