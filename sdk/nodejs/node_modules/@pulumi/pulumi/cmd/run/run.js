"use strict";
// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const url = __importStar(require("url"));
const path = __importStar(require("path"));
const tsnode = __importStar(require("ts-node"));
const ini = __importStar(require("ini"));
const semver = __importStar(require("semver"));
const errors_1 = require("../../errors");
const log = __importStar(require("../../log"));
const stack = __importStar(require("../../runtime/stack"));
const settings = __importStar(require("../../runtime/settings"));
const tracing = __importStar(require("./tracing"));
const tsutils = __importStar(require("../../tsutils"));
const mod = __importStar(require("."));
/**
 * Attempts to provide a detailed error message for module load failure if the
 * module that failed to load is the top-level module.
 * @param program The name of the program given to `run`, i.e. the top level module
 * @param error The error that occured. Must be a module load error.
 */
function reportModuleLoadFailure(program, error) {
    throwOrPrintModuleLoadError(program, error);
    // Note: from this point on, we've printed something to the user telling them about the
    // problem.  So we can let our langhost know it doesn't need to report any further issues.
    return process.exit(mod.nodeJSProcessExitedAfterLoggingUserActionableMessage);
}
function projectRootFromProgramPath(program) {
    const stat = fs.lstatSync(program);
    if (stat.isDirectory()) {
        return program;
    }
    else {
        return path.dirname(program);
    }
}
function packageObjectFromProjectRoot(projectRoot) {
    try {
        const packageJson = path.join(projectRoot, "package.json");
        return require(packageJson);
    }
    catch (_a) {
        // This is all best-effort so if we can't load the package.json file, that's
        // fine.
        return {};
    }
}
// Reads and parses the contents of .npmrc file if it exists under the project root
// This assumes that .npmrc is a sibling to package.json
function npmRcFromProjectRoot(projectRoot) {
    const rcSpan = tracing.newSpan("language-runtime.reading-npm-rc");
    const emptyConfig = {};
    try {
        const npmRcPath = path.join(projectRoot, ".npmrc");
        if (!fs.existsSync(npmRcPath)) {
            return emptyConfig;
        }
        // file .npmrc exists, read its contents
        const npmRc = fs.readFileSync(npmRcPath, "utf-8");
        // Use ini to parse the contents of the .npmrc file
        // This is what node does as described in the npm docs
        // https://docs.npmjs.com/cli/v8/configuring-npm/npmrc#comments
        const parseResult = ini.parse(npmRc);
        rcSpan.end();
        return parseResult;
    }
    catch (_a) {
        // .npmrc file exists but we couldn't read or parse it
        // user out of luck here
        rcSpan.end();
        return emptyConfig;
    }
}
function throwOrPrintModuleLoadError(program, error) {
    // error is guaranteed to be a Node module load error. Node emits a very
    // specific string in its error message for module load errors, which includes
    // the module it was trying to load.
    const errorRegex = /Cannot find module '(.*)'/;
    // If there's no match, who knows what this exception is; it's not something
    // we can provide an intelligent diagnostic for.
    const moduleNameMatches = errorRegex.exec(error.message);
    if (moduleNameMatches === null) {
        throw error;
    }
    // Is the module that failed to load exactly the one that this script considered to
    // be the top-level module for this program?
    //
    // We are only interested in producing good diagnostics for top-level module loads,
    // since anything else are probably user code issues.
    const moduleName = moduleNameMatches[1];
    if (moduleName !== program) {
        throw error;
    }
    // Note: from this point on, we've printed something to the user telling them about the
    // problem.  So we can let our langhost know it doesn't need to report any further issues.
    console.error(`We failed to locate the entry point for your program: ${program}`);
    // From here on out, we're going to try to inspect the program we're being asked to run
    // a little to see what sort of details we can glean from it, in the hopes of producing
    // a better error message.
    //
    // The first step of this is trying to slurp up a package.json for this program, if
    // one exists.
    const projectRoot = projectRootFromProgramPath(program);
    const packageObject = packageObjectFromProjectRoot(projectRoot);
    console.error("Here's what we think went wrong:");
    // The objective here is to emit the best diagnostic we can, starting from the
    // most specific to the least specific.
    const deps = packageObject["dependencies"] || {};
    const devDeps = packageObject["devDependencies"] || {};
    const scripts = packageObject["scripts"] || {};
    const mainProperty = packageObject["main"] || "index.js";
    // Is there a build script associated with this program? It's a little confusing that the
    // Pulumi CLI doesn't run build scripts before running the program so call that out
    // explicitly.
    if ("build" in scripts) {
        const command = scripts["build"];
        console.error(`  * Your program looks like it has a build script associated with it ('${command}').\n`);
        console.error("Pulumi does not run build scripts before running your program. " +
            `Please run '${command}', 'yarn build', or 'npm run build' and try again.`);
        return;
    }
    // Not all typescript programs have build scripts. If we think it's a typescript program,
    // tell the user to run tsc.
    if ("typescript" in deps || "typescript" in devDeps) {
        console.error("  * Your program looks like a TypeScript program. Have you run 'tsc'?");
        return;
    }
    // Not all projects are typescript. If there's a main property, check that the file exists.
    if (mainProperty !== undefined && typeof mainProperty === "string") {
        const mainFile = path.join(projectRoot, mainProperty);
        if (!fs.existsSync(mainFile)) {
            console.error(`  * Your program's 'main' file (${mainFile}) does not exist.`);
            return;
        }
    }
    console.error("  * Pulumi encountered an unexpected error.");
    console.error(`    Raw exception message: ${error.message}`);
    return;
}
function tracingIsEnabled(tracingUrl) {
    var _a;
    if (typeof tracingUrl !== "string") {
        return false;
    }
    const experimental = (_a = process.env["PULUMI_EXPERIMENTAL"]) !== null && _a !== void 0 ? _a : "";
    const nonzeroLength = tracingUrl.length > 0;
    const experimentalEnabled = experimental.length > 0;
    return nonzeroLength && experimentalEnabled;
}
/** @internal */
function run(argv, programStarted, reportLoggedError, isErrorReported) {
    var _a, _b;
    const tracingUrl = argv["tracing"];
    // Start tracing. Before exiting, gracefully shutdown tracing, exporting
    // all remaining spans in the batch.
    if (tracingIsEnabled(tracingUrl)) {
        tracing.start(tracingUrl); // safe cast, since tracingIsEnable confirmed the type
        process.on("exit", tracing.stop);
    }
    // Start a new span, which we shutdown at the bottom of this method.
    const span = tracing.newSpan("language-runtime.run");
    // If there is a --pwd directive, switch directories.
    const pwd = argv["pwd"];
    if (pwd) {
        process.chdir(pwd);
    }
    // If this is a typescript project, we'll want to load node-ts.
    const typeScript = process.env["PULUMI_NODEJS_TYPESCRIPT"] === "true";
    // We provide reasonable defaults for many ts options, meaning you don't need to have a tsconfig.json present
    // if you want to use TypeScript with Pulumi. However, ts-node's default behavior is to walk up from the cwd to
    // find a tsconfig.json. For us, it's reasonable to say that the "root" of the project is the cwd,
    // if there's a tsconfig.json file here. Otherwise, just tell ts-node to not load project options at all.
    // This helps with cases like pulumi/pulumi#1772.
    const defaultTsConfigPath = "tsconfig.json";
    const tsConfigPath = (_a = process.env["PULUMI_NODEJS_TSCONFIG_PATH"]) !== null && _a !== void 0 ? _a : defaultTsConfigPath;
    const skipProject = !fs.existsSync(tsConfigPath);
    span.setAttribute("typescript-enabled", typeScript);
    if (typeScript) {
        const transpileOnly = ((_b = process.env["PULUMI_NODEJS_TRANSPILE_ONLY"]) !== null && _b !== void 0 ? _b : "false") === "true";
        const compilerOptions = tsutils.loadTypeScriptCompilerOptions(tsConfigPath);
        const tsn = require("ts-node");
        tsn.register({
            transpileOnly,
            // PULUMI_NODEJS_TSCONFIG_PATH might be set to a config file such as "tsconfig.pulumi.yaml" which
            // would not get picked up by tsnode by default, so we explicitly tell tsnode which config file to
            // use (Which might just be ./tsconfig.yaml)
            project: tsConfigPath,
            skipProject: skipProject,
            compilerOptions: Object.assign({ target: "es6", module: "commonjs", moduleResolution: "node", sourceMap: "true" }, compilerOptions),
        });
    }
    let program = argv._[0];
    if (!path.isAbsolute(program)) {
        // If this isn't an absolute path, make it relative to the working directory.
        program = path.join(process.cwd(), program);
    }
    // Now fake out the process-wide argv, to make the program think it was run normally.
    const programArgs = argv._.slice(1);
    process.argv = [process.argv[0], process.argv[1], ...programArgs];
    // Set up the process uncaught exception, unhandled rejection, and program exit handlers.
    const uncaughtHandler = (err) => {
        var _a;
        // In node, if you throw an error in a chained promise, but the exception is not finally
        // handled, then you can end up getting an unhandledRejection for each exception/promise
        // pair.  Because the exception is the same through all of these, we keep track of it and
        // only report it once so the user doesn't get N messages for the same thing.
        if (isErrorReported(err)) {
            return;
        }
        // Default message should be to include the full stack (which includes the message), or
        // fallback to just the message if we can't get the stack.
        //
        // If both the stack and message are empty, then just stringify the err object itself. This
        // is also necessary as users can throw arbitrary things in JS (including non-Errors).
        const defaultMessage = err.stack || err.message || ("" + err);
        // First, log the error.
        if (errors_1.RunError.isInstance(err)) {
            // Always hide the stack for RunErrors.
            log.error(err.message);
        }
        else if (err.name === tsnode.TSError.name
            || err.name === SyntaxError.name) {
            // Hide stack frames as TSError/SyntaxError have messages containing
            // where the error is located
            const errOut = ((_a = err.stack) === null || _a === void 0 ? void 0 : _a.toString()) || "";
            let errMsg = err.message;
            const errParts = errOut.split(err.message);
            if (errParts.length === 2) {
                errMsg = errParts[0] + err.message;
            }
            log.error(`Running program '${program}' failed with an unhandled exception:
${errMsg}`);
        }
        else if (errors_1.ResourceError.isInstance(err)) {
            // Hide the stack if requested to by the ResourceError creator.
            const message = err.hideStack ? err.message : defaultMessage;
            log.error(message, err.resource);
        }
        else {
            log.error(`Running program '${program}' failed with an unhandled exception:
${defaultMessage}`);
        }
        span.addEvent(`uncaughtError: ${err}`);
        reportLoggedError(err);
    };
    process.on("uncaughtException", uncaughtHandler);
    // @ts-ignore 'unhandledRejection' will almost always invoke uncaughtHandler with an Error. so
    // just suppress the TS strictness here.
    process.on("unhandledRejection", uncaughtHandler);
    process.on("exit", settings.disconnectSync);
    programStarted();
    // This needs to occur after `programStarted` to ensure execution of the parent process stops.
    if (skipProject && tsConfigPath !== defaultTsConfigPath) {
        span.addEvent("Missing tsconfig file");
        return new Promise(() => {
            const e = new Error(`tsconfig path was set to ${tsConfigPath} but the file was not found`);
            e.stack = undefined;
            throw e;
        });
    }
    const containsTSAndJSModules = (programPath) => __awaiter(this, void 0, void 0, function* () {
        const programStats = yield fs.promises.lstat(programPath);
        if (programStats.isDirectory()) {
            const programDirFiles = yield fs.promises.readdir(programPath);
            return programDirFiles.includes("index.js") && programDirFiles.includes("index.ts");
        }
        else {
            return false;
        }
    });
    const runProgram = () => __awaiter(this, void 0, void 0, function* () {
        // We run the program inside this context so that it adopts all resources.
        //
        // IDEA: This will miss any resources created on other turns of the event loop.  I think that's a fundamental
        // problem with the current Component design though - not sure what else we could do here.
        //
        // Now go ahead and execute the code. The process will remain alive until the message loop empties.
        log.debug(`Running program '${program}' in pwd '${process.cwd()}' w/ args: ${programArgs}`);
        // Create a new span for the execution of the user program.
        const runProgramSpan = tracing.newSpan("language-runtime.runProgram");
        try {
            const projectRoot = projectRootFromProgramPath(program);
            const packageObject = packageObjectFromProjectRoot(projectRoot);
            let programExport;
            // We use dynamic import instead of require for projects using native ES modules instead of commonjs
            if (packageObject["type"] === "module") {
                // Use the same behavior for loading the main entrypoint as `node <program>`.
                // See https://github.com/nodejs/node/blob/master/lib/internal/modules/run_main.js#L74.
                const mainPath = require("module").Module._findPath(path.resolve(program), null, true) || program;
                const main = path.isAbsolute(mainPath) ? url.pathToFileURL(mainPath).href : mainPath;
                // Workaround for typescript transpiling dynamic import into `Promise.resolve().then(() => require`
                // Follow this issue for progress on when we can remove this:
                // https://github.com/microsoft/TypeScript/issues/43329
                //
                // Workaround inspired by es-module-shims:
                // https://github.com/guybedford/es-module-shims/blob/main/src/common.js#L21
                // eslint-disable-next-line no-eval
                const dynamicImport = (0, eval)("u=>import(u)");
                // Import the module and capture any module outputs it exported. Finally, await the value we get
                // back.  That way, if it is async and throws an exception, we properly capture it here
                // and handle it.
                programExport = yield dynamicImport(main);
                // If there is a default export, use that instead of the named exports (and error if there are both).
                if (Object.getOwnPropertyDescriptor(programExport, "default") !== undefined) {
                    if (Object.keys(programExport).length !== 1) {
                        throw new Error("expected entrypoint module to have either a default export or named exports but not both");
                    }
                    programExport = programExport.default;
                }
            }
            else {
                // It's a CommonJS module, so require the module and capture any module outputs it exported.
                programExport = require(program);
            }
            if (yield containsTSAndJSModules(program)) {
                log.warn("Found a TypeScript project containing an index.js file and no explicit entrypoint in Pulumi.yaml - Pulumi will use index.js");
            }
            ;
            // Check compatible engines before running the program:
            const npmRc = npmRcFromProjectRoot(projectRoot);
            if (npmRc["engine-strict"] && packageObject.engines && packageObject.engines.node) {
                // found:
                //   - { engines: { node: "<version>" } } in package.json
                //   - engine-strict=true in .npmrc
                //
                // Check that current node version satistfies the required version
                const requiredNodeVersion = packageObject.engines.node;
                const currentNodeVersion = process.versions.node;
                if (!semver.satisfies(currentNodeVersion, requiredNodeVersion)) {
                    const errorMessage = [
                        `Your current Node version is incompatible to run ${projectRoot}`,
                        `Expected version: ${requiredNodeVersion} as found in package.json > engines > node`,
                        `Actual Node version: ${currentNodeVersion}`,
                        `To fix issue, install a Node version that is compatible with ${requiredNodeVersion}`,
                    ];
                    runProgramSpan.addEvent("Incompatible Node version");
                    throw new Error(errorMessage.join("\n"));
                }
            }
            // If the exported value was itself a Function, then just execute it.  This allows for
            // exported top level async functions that pulumi programs can live in.  Finally, await
            // the value we get back.  That way, if it is async and throws an exception, we properly
            // capture it here and handle it.
            const invokeResult = programExport instanceof Function
                ? programExport()
                : programExport;
            runProgramSpan.end();
            return yield invokeResult;
        }
        catch (e) {
            // User JavaScript can throw anything, so if it's not an Error it's definitely
            // not something we want to catch up here.
            if (!(e instanceof Error)) {
                throw e;
            }
            // Give a better error message, if we can.
            const errorCode = e.code;
            if (errorCode === "MODULE_NOT_FOUND") {
                runProgramSpan.addEvent("Module Load Failure.");
                reportModuleLoadFailure(program, e);
            }
            throw e;
        }
        finally {
            runProgramSpan.end();
        }
    });
    // Construct a `Stack` resource to represent the outputs of the program.
    const stackOutputs = stack.runInPulumiStack(runProgram);
    span.end();
    return stackOutputs;
}
exports.run = run;
//# sourceMappingURL=run.js.map