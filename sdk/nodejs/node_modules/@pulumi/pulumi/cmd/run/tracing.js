// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const packageJson = __importStar(require("../../package.json"));
const opentelemetry = __importStar(require("@opentelemetry/api"));
const resources_1 = require("@opentelemetry/resources");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const exporter_zipkin_1 = require("@opentelemetry/exporter-zipkin");
const instrumentation_grpc_1 = require("@opentelemetry/instrumentation-grpc");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const log = __importStar(require("../../log"));
let exporter;
let rootSpan;
// serviceName is the name of this service in the Pulumi
// distributed system, and the name of the tracer we're using.
const serviceName = "nodejs-runtime";
// If the URL provided matches the default generated by the engine,
// we must transform it to be compatible with the OpenTelemetry Zipkin
// library.
function validateUrl(destination) {
    if (destination.startsWith("tcp://127.0.0.1")) {
        // This URI is invalid because the OpenTelemetry expects
        // a Zipkin-compatible API. This URI is likely sent by the Engine's
        // AppDash server when the user specifies a file endpoint.
        // In this case, we send a warning that we can't support this URI
        // and refuse to enable tracing.
        log.warn("Detected an incompatible tracing URI. Refusing to enable tracing for the NodeJS runtime. If you provided a file target with the --tracing flag, understand that the NodeJS runtime does not support sending trace information to files.");
        return false;
    }
    return true;
}
/** @internal */
function start(destinationUrl) {
    if (!validateUrl(destinationUrl)) {
        return;
    }
    // Set up gRPC auto-instrumentation.
    instrumentation_1.registerInstrumentations({
        instrumentations: [new instrumentation_grpc_1.GrpcInstrumentation()],
    });
    // Tag traces from this program with metadata about their source.
    const resource = resources_1.Resource.default().merge(new resources_1.Resource({
        [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: serviceName,
        [semantic_conventions_1.SemanticResourceAttributes.SERVICE_VERSION]: packageJson.version,
    }));
    /**
     * Taken from OpenTelemetry Examples (Apache 2 License):
     * https://github.com/open-telemetry/opentelemetry-js/blob/a8d39317b5daad727f2116ca314db0d1420ec488/examples/basic-tracer-node/index.js
     * Initialize the OpenTelemetry APIs to use the BatchTracerProvider bindings.
     *
     * A "tracer provider" is a factory for tracers. By registering the provider,
     * we allow tracers of the given type to be globally contructed.
     * As a result, when you call API methods like
     * `opentelemetry.trace.getTracer`, the tracer is generated via the tracer provder
     * registered here.
     */
    // Create a new tracer provider, acting as a factory for tracers.
    const provider = new sdk_trace_node_1.NodeTracerProvider({
        resource: resource,
    });
    // Configure span processor to send spans to the exporter
    log.debug(`Registering tracing url: ${destinationUrl}`);
    exporter = new exporter_zipkin_1.ZipkinExporter({ url: destinationUrl, serviceName });
    provider.addSpanProcessor(new sdk_trace_base_1.SimpleSpanProcessor(exporter));
    provider.register();
    const tracer = opentelemetry.trace.getTracer("nodejs-runtime");
    // Create a root span, which must be closed.
    rootSpan = tracer.startSpan("nodejs-runtime-root");
}
exports.start = start;
/** @internal */
function stop() {
    // If rootSpan is null, the URI provided was invalid,
    // so tracing was never enabled.
    if (rootSpan != null) {
        log.debug("Shutting down tracer.");
        // Always close the root span.
        rootSpan.end();
    }
    // Do not bother stopping the tracing exporter. Because we use a
    // SimpleSpanProcessor, it eagerly sends spans.
}
exports.stop = stop;
/** @internal */
function newSpan(name) {
    var _a;
    const tracer = opentelemetry.trace.getTracer(serviceName);
    const parentSpan = (_a = opentelemetry.trace.getActiveSpan()) !== null && _a !== void 0 ? _a : rootSpan;
    const activeCtx = opentelemetry.context.active();
    const ctx = opentelemetry.trace.setSpan(activeCtx, parentSpan);
    const childSpan = tracer.startSpan(name, undefined, ctx);
    return childSpan;
}
exports.newSpan = newSpan;
//# sourceMappingURL=tracing.js.map