// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package aws

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides an AWS Lambda Function with additional necesary resources. It bundles several resources such as `Lambda Functions`, `Function URLs`, `CloudWatch keep-warm rules`, `Log Group with a Retention Policy`, `Role to run Lambda and Write Logs`. It also has a feature for schedule (cron) definitions and automated X-Ray tracing.
//
// ## Example Usage
type ContainerFunction struct {
	pulumi.ResourceState

	// ARN (Amazon Resource Name) of the Lambda Function.
	Arn pulumi.StringOutput `pulumi:"arn"`
	// Name of the Lambda Function.
	Name pulumi.StringOutput `pulumi:"name"`
	// Lambda Function URL (Only valid if `urlEnabled` is used).
	Url pulumi.StringPtrOutput `pulumi:"url"`
}

// NewContainerFunction registers a new resource with the given unique name, arguments, and options.
func NewContainerFunction(ctx *pulumi.Context,
	name string, args *ContainerFunctionArgs, opts ...pulumi.ResourceOption) (*ContainerFunction, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ImageUri == nil {
		return nil, errors.New("invalid value for required argument 'ImageUri'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource ContainerFunction
	err := ctx.RegisterRemoteComponentResource("nuage:aws:ContainerFunction", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type containerFunctionArgs struct {
	// Architecture, either `X86_64` or `ARM64`. Defaults to `X86_64`
	Architecture *string `pulumi:"architecture"`
	// Description of the function.
	Description *string `pulumi:"description"`
	// Environment Variables
	Environment map[string]string `pulumi:"environment"`
	// Image uri of the docker image.
	ImageUri string `pulumi:"imageUri"`
	// Keep warm by refreshing the lambda function every 5 minutes. Defaults to `false`
	KeepWarm *bool `pulumi:"keepWarm"`
	// Number of days for log retention to pass in cloudwatch log group. Defaults to `90`
	LogRetentionInDays *int `pulumi:"logRetentionInDays"`
	// Amount of memory in MB your Lambda Function can use at runtime. Defaults to `512`.
	MemorySize *int `pulumi:"memorySize"`
	// Name of the resource.
	Name *string `pulumi:"name"`
	// Name prefix as an alternative to name and adds random suffix at the end.
	NamePrefix *string `pulumi:"namePrefix"`
	// Policy Document for lambda.
	PolicyDocument *string `pulumi:"policyDocument"`
	// Configure the function's cloudwatch event rule schedule.
	ScheduleConfig *FunctionSchedule `pulumi:"scheduleConfig"`
	// Amount of time your Lambda Function has to run in seconds. Defaults to `3`
	Timeout *int `pulumi:"timeout"`
	// Configure lambda function url.
	UrlConfig *FunctionUrl `pulumi:"urlConfig"`
}

// The set of arguments for constructing a ContainerFunction resource.
type ContainerFunctionArgs struct {
	// Architecture, either `X86_64` or `ARM64`. Defaults to `X86_64`
	Architecture pulumi.StringPtrInput
	// Description of the function.
	Description pulumi.StringPtrInput
	// Environment Variables
	Environment pulumi.StringMapInput
	// Image uri of the docker image.
	ImageUri pulumi.StringInput
	// Keep warm by refreshing the lambda function every 5 minutes. Defaults to `false`
	KeepWarm pulumi.BoolPtrInput
	// Number of days for log retention to pass in cloudwatch log group. Defaults to `90`
	LogRetentionInDays pulumi.IntPtrInput
	// Amount of memory in MB your Lambda Function can use at runtime. Defaults to `512`.
	MemorySize pulumi.IntPtrInput
	// Name of the resource.
	Name pulumi.StringPtrInput
	// Name prefix as an alternative to name and adds random suffix at the end.
	NamePrefix pulumi.StringPtrInput
	// Policy Document for lambda.
	PolicyDocument pulumi.StringPtrInput
	// Configure the function's cloudwatch event rule schedule.
	ScheduleConfig FunctionSchedulePtrInput
	// Amount of time your Lambda Function has to run in seconds. Defaults to `3`
	Timeout pulumi.IntPtrInput
	// Configure lambda function url.
	UrlConfig FunctionUrlPtrInput
}

func (ContainerFunctionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*containerFunctionArgs)(nil)).Elem()
}

type ContainerFunctionInput interface {
	pulumi.Input

	ToContainerFunctionOutput() ContainerFunctionOutput
	ToContainerFunctionOutputWithContext(ctx context.Context) ContainerFunctionOutput
}

func (*ContainerFunction) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFunction)(nil)).Elem()
}

func (i *ContainerFunction) ToContainerFunctionOutput() ContainerFunctionOutput {
	return i.ToContainerFunctionOutputWithContext(context.Background())
}

func (i *ContainerFunction) ToContainerFunctionOutputWithContext(ctx context.Context) ContainerFunctionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFunctionOutput)
}

// ContainerFunctionArrayInput is an input type that accepts ContainerFunctionArray and ContainerFunctionArrayOutput values.
// You can construct a concrete instance of `ContainerFunctionArrayInput` via:
//
//	ContainerFunctionArray{ ContainerFunctionArgs{...} }
type ContainerFunctionArrayInput interface {
	pulumi.Input

	ToContainerFunctionArrayOutput() ContainerFunctionArrayOutput
	ToContainerFunctionArrayOutputWithContext(context.Context) ContainerFunctionArrayOutput
}

type ContainerFunctionArray []ContainerFunctionInput

func (ContainerFunctionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ContainerFunction)(nil)).Elem()
}

func (i ContainerFunctionArray) ToContainerFunctionArrayOutput() ContainerFunctionArrayOutput {
	return i.ToContainerFunctionArrayOutputWithContext(context.Background())
}

func (i ContainerFunctionArray) ToContainerFunctionArrayOutputWithContext(ctx context.Context) ContainerFunctionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFunctionArrayOutput)
}

// ContainerFunctionMapInput is an input type that accepts ContainerFunctionMap and ContainerFunctionMapOutput values.
// You can construct a concrete instance of `ContainerFunctionMapInput` via:
//
//	ContainerFunctionMap{ "key": ContainerFunctionArgs{...} }
type ContainerFunctionMapInput interface {
	pulumi.Input

	ToContainerFunctionMapOutput() ContainerFunctionMapOutput
	ToContainerFunctionMapOutputWithContext(context.Context) ContainerFunctionMapOutput
}

type ContainerFunctionMap map[string]ContainerFunctionInput

func (ContainerFunctionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ContainerFunction)(nil)).Elem()
}

func (i ContainerFunctionMap) ToContainerFunctionMapOutput() ContainerFunctionMapOutput {
	return i.ToContainerFunctionMapOutputWithContext(context.Background())
}

func (i ContainerFunctionMap) ToContainerFunctionMapOutputWithContext(ctx context.Context) ContainerFunctionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFunctionMapOutput)
}

type ContainerFunctionOutput struct{ *pulumi.OutputState }

func (ContainerFunctionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFunction)(nil)).Elem()
}

func (o ContainerFunctionOutput) ToContainerFunctionOutput() ContainerFunctionOutput {
	return o
}

func (o ContainerFunctionOutput) ToContainerFunctionOutputWithContext(ctx context.Context) ContainerFunctionOutput {
	return o
}

type ContainerFunctionArrayOutput struct{ *pulumi.OutputState }

func (ContainerFunctionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ContainerFunction)(nil)).Elem()
}

func (o ContainerFunctionArrayOutput) ToContainerFunctionArrayOutput() ContainerFunctionArrayOutput {
	return o
}

func (o ContainerFunctionArrayOutput) ToContainerFunctionArrayOutputWithContext(ctx context.Context) ContainerFunctionArrayOutput {
	return o
}

func (o ContainerFunctionArrayOutput) Index(i pulumi.IntInput) ContainerFunctionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ContainerFunction {
		return vs[0].([]*ContainerFunction)[vs[1].(int)]
	}).(ContainerFunctionOutput)
}

type ContainerFunctionMapOutput struct{ *pulumi.OutputState }

func (ContainerFunctionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ContainerFunction)(nil)).Elem()
}

func (o ContainerFunctionMapOutput) ToContainerFunctionMapOutput() ContainerFunctionMapOutput {
	return o
}

func (o ContainerFunctionMapOutput) ToContainerFunctionMapOutputWithContext(ctx context.Context) ContainerFunctionMapOutput {
	return o
}

func (o ContainerFunctionMapOutput) MapIndex(k pulumi.StringInput) ContainerFunctionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ContainerFunction {
		return vs[0].(map[string]*ContainerFunction)[vs[1].(string)]
	}).(ContainerFunctionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFunctionInput)(nil)).Elem(), &ContainerFunction{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFunctionArrayInput)(nil)).Elem(), ContainerFunctionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFunctionMapInput)(nil)).Elem(), ContainerFunctionMap{})
	pulumi.RegisterOutputType(ContainerFunctionOutput{})
	pulumi.RegisterOutputType(ContainerFunctionArrayOutput{})
	pulumi.RegisterOutputType(ContainerFunctionMapOutput{})
}
